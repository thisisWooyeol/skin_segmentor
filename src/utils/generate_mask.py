import argparse
import logging
import os
import re

import cv2
import numpy as np
from tqdm import tqdm

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(module)-18s - %(levelname)-8s - %(message)s",
)
logger = logging.getLogger(__name__)


def generate_single_mask(
    img1_path: str, img2_path: str, out_path: str | None = None, threshold: int = 20
) -> None:
    """
    Generate a mask image by comparing two images pixel by pixel.
    The mask image is generated by comparing the two images and marking the differences.
    Background pixels are marked with black, and the mask area is marked with white.

    Args:
        img1_path (str): Path to the original image.
        img2_path (str): Path to the marked image.
        out_path (str | None): Optional output path for the mask image. If None, the mask image will be saved
            in the same directory as the original image with '_mask_' in the filename.
        threshold (int): Threshold value for the mask generation. Default is 20.
            Required value for each task: acne: 20 / hemo: 7

    Raises:
        FileNotFoundError: If one of the input images cannot be read.
        ValueError: If the input images do not have the same dimensions and channels.

    Example:
        >>> generate_single_mask(
        ...     "examples/201810271724239_KR_0_18_org_acne.jpg",
        ...     "examples/201810271724239_KR_0_18_39_acne.jpg",
        ... )
        # saves mask to "examples/201810271724239_KR_0_18_mask_acne.jpg"
    """
    # load images
    img1 = cv2.imread(img1_path)
    img2 = cv2.imread(img2_path)
    if img1 is None or img2 is None:
        raise FileNotFoundError("One of the input images could not be read.")
    if img1.shape != img2.shape:
        raise ValueError("Input images must have the same dimensions & channels.")

    # compute absolute difference and convert to gray
    diff = cv2.absdiff(img1, img2)
    # # ! FIXME: enable cvtColor for mela only
    # gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
    # ! FIXME: for acne, hemo
    gray = np.max(diff, axis=2).astype(np.uint8)  # max across channels

    # threshold: any non-zero → 255
    # NOTE: Use a threshold to ignore small differences
    _, mask = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)

    # determine output path
    if out_path is None:
        base = os.path.basename(img1_path)
        out_name = base.replace("_org_", "_mask_")
        out_path = os.path.join(os.path.dirname(img1_path), out_name)

    # save mask
    cv2.imwrite(out_path, mask)
    logger.debug(f"Mask saved to: {out_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate a binary mask by pixel-wise comparison of two images."
    )
    parser.add_argument(
        "--dataset_dir",
        required=True,
        help="path to dataset directory with original/marked images",
    )
    parser.add_argument(
        "--threshold",
        type=int,
        default=20,
        help="threshold value for mask generation (default: 20)",
    )
    args = parser.parse_args()

    # Batch mode: process all original/marked pairs in a dataset directory
    dataset_dir = args.dataset_dir

    for fname in tqdm(sorted(os.listdir(dataset_dir))):
        if "_org_" not in fname:
            continue

        img1_path = os.path.join(dataset_dir, fname)
        # infer the marked image by wildcard‐matching the arbitrary number
        prefix, suffix = fname.split("_org_")
        # build a regex: prefix, one or more digits, then suffix
        pattern = re.compile(rf"^{re.escape(prefix)}_\d+_{re.escape(suffix)}$")

        # list files matching the regex
        candidates = [
            os.path.join(dataset_dir, fname)
            for fname in os.listdir(dataset_dir)
            if pattern.match(fname)
        ]

        if not candidates:
            logger.error(
                f"Skipping '{fname}': no marked file matching '{prefix}_*_{suffix}'"
            )
            continue
        if len(candidates) > 1:
            logger.error(f"Skipping '{fname}': multiple matches found: {candidates}")
            continue

        img2_path = candidates[0]

        generate_single_mask(img1_path, img2_path, threshold=args.threshold)


if __name__ == "__main__":
    main()
